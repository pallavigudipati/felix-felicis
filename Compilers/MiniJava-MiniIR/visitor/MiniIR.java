//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;

import java.text.ParseException;
import java.util.*;
import java.util.Map.Entry;

import javax.crypto.AEADBadTagException;
import javax.swing.text.Position;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */

public class MiniIR<R> implements GJNoArguVisitor<R> {
	// My code.
	//private HashMap<String, String> symbolTable = new HashMap<String, String>();
	/*
	private class Method {
		public Map<String, Integer> args = new LinkedHashMap<String, Integer>();
		public Map<String, Integer> vars = new LinkedHashMap<String, Integer>();
		public boolean overridden = false;
	}*/
	/*
	private class Info {
		public Map<String, Method> methods = new LinkedHashMap<String, Method>();
		public Map<String, Integer> variables = new LinkedHashMap<String, Integer>(); 
	}
	*/
	private HashSet<String> classes = new HashSet<String>();
	private HashMap<String, String> extendClass = new HashMap<String, String>();
	private HashMap<String, Info> symbolTable = new HashMap<String, Info>();
	
	private Map<String, String> methodCall = new LinkedHashMap<String, String>();
	private Map<String, String> returnTypeMap = new LinkedHashMap<String, String>();
	
	private Stack<String> argumentStack = new Stack<String>();
	private Stack<String> returnStack = new Stack<String>();
	
	private String currentClass = new String();
	private String currentMethod = new String();
	
	boolean globalFlag = false;
	// takes all the extends cases and checks valid declarations in VarDeclarations
	boolean onlyForExtends = false;
	boolean enteringExtends = false;
	boolean thisFlag = false;

	boolean notThisIdFlag = false;
	boolean messageFlag = false;
	int tempIter = 20;
	int labelIter = 0;
	int paramIt = 0;
	int varIt = 0;
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() )
         return n.node.accept(this);
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //
   
   public boolean FindExtend (String a, String b) {
	   boolean sentinel = true;
	   String temp = new String();
	   temp = a;
	   while (sentinel) {
		   if (extendClass.get(temp) != null) {
			   if (b == extendClass.get(temp)) {
				   return true;
			   } else {
				   temp = extendClass.get(temp);
			   }
		   } else {
			   sentinel = false;
		   }
	   }
	   return false;
   }

   public String getTemp() {
	   String temp = new String();
	   temp = "TEMP " + tempIter;
	   tempIter++;
	   return temp;
   }
   
   public String getLabel() {
	   String temp = new String();
	   temp = "L" + labelIter;
	   labelIter++;
	   return temp;
   }
   
   public void setParamIt() {
	   paramIt = 0;
   }
   
   public int getParamIt() {
	   int temp = paramIt;
	   paramIt++;
	   return temp;
   }
   /*
   public void setVarIt(int param) {
	   varIt = param;
   }
   
   public int getVarIt() {
	   int temp = varIt;
	   varIt++;
	   return temp;
   }*/
   
   public int getMethodIndex(String className, String methodName) {
	   int i = 0; 
	   for (String key : symbolTable.get(className).methods.keySet()) {
		   if (key.equals(methodName)) {
			   return i;
		   }
		   i++;
	   }
	   return -1;
   }
   
   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      
      onlyForExtends = true;
      
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
	  
      onlyForExtends = false;   
      globalFlag = true;
      
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   // TODO extra extends
   public R visit(MainClass n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
     
      currentClass = (String)n.f1.f0.toString();
      classes.add(currentClass);
      currentMethod = "";
      
      if (!globalFlag && !onlyForExtends) {
          Info temp = new Info();
          symbolTable.put(currentClass, temp);
      }
     
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      n.f13.accept(this);
      
      if (globalFlag) {
    	  System.out.println("MAIN\n");
      }
      
      String prStmt = (String)n.f14.accept(this);
      
      n.f15.accept(this);
      n.f16.accept(this);
      
      if (globalFlag) {
    	  System.out.println("END\n");
      }
      
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      
      currentClass = n.f1.f0.toString();
      classes.add(currentClass);
      currentMethod = "";
      
      if (!globalFlag) {
    	  if (!onlyForExtends || (onlyForExtends && enteringExtends)) {
    		  Info temp = new Info();
    		  symbolTable.put(currentClass, temp);
    	  }
      }
      
      n.f2.accept(this);
      
     // setVarIt(0);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n) {
      R _ret=null;
      
      enteringExtends = true;
      
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      
      currentClass = n.f1.f0.toString();
      classes.add(currentClass);
      currentMethod = "";
      String class1 = n.f1.f0.toString();
      String class2 = n.f3.f0.toString();
      
      extendClass.put(class1, class2);
      
      //TODO linkedhashmap....if something is overwritten, is the order maintained?
      if (!globalFlag && onlyForExtends) {    	  
		  // symbolTable
    	  Info baseClass = symbolTable.get(class2);
    	  Info infoTemp = new Info();
		  infoTemp.methods.putAll(baseClass.methods);
		  infoTemp.variables.putAll(baseClass.variables);
		  symbolTable.put(currentClass, infoTemp);
    	  
		  // methodCall
		  Map<String, String> methodTemp = new LinkedHashMap<String, String>();
		  for (String key : methodCall.keySet()) {
			  if (key.startsWith(class2)) {
				  String temp = new String();
				  temp = key.replace(class2, class1);
				  methodTemp.put(temp, methodCall.get(key));
			  }
		  }
		  for (String key : methodTemp.keySet()) {
			  methodCall.put(key, methodTemp.get(key));
		  }
		  
		  // returnTypeMap
		  Map<String, String> returnTemp = new LinkedHashMap<String, String>();
		  for (String key : returnTypeMap.keySet()) {
			  if (key.startsWith(class2)) {
				  String temp = new String();
				  temp = key.replace(class2, class1);
				  returnTemp.put(temp, returnTypeMap.get(key));
			  }
		  }
		  for (String key : returnTemp.keySet()) {
			  returnTypeMap.put(key, returnTemp.get(key));
		  }
		  
	      n.f4.accept(this);
	     // setVarIt(symbolTable.get(currentClass).variables.size() + 1);
	      n.f5.accept(this);
	      n.f6.accept(this);
	      n.f7.accept(this);
      }
      
      if (globalFlag) {
	      n.f4.accept(this);
	      n.f5.accept(this);
	      n.f6.accept(this);
	      n.f7.accept(this);
      }
      
      enteringExtends = false;
      return _ret;
   }
   
   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n) {
      R _ret=null;
      String type = (String)n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      
      if (!globalFlag) {
		  String id = new String();
		  id = n.f1.f0.toString();
    	  if (!onlyForExtends || (onlyForExtends && enteringExtends)) {    		  
    		  if (type != null) {
    			  methodCall.put(currentClass + " " + currentMethod + " " + id, type);
    		  }
    		  
    		  if (currentMethod == "") {
    			  int var = symbolTable.get(currentClass).variables.size();
    			  symbolTable.get(currentClass).variables.put(id, var);
    		  } else {
    			  symbolTable.get(currentClass).methods.get(currentMethod)
    			  	.vars.put(id, tempIter);
    			  tempIter++;
    		  }
    	  } 
      }
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n) {
      R _ret=null;
      n.f0.accept(this);
      String returnType = (String)n.f1.accept(this);
      n.f2.accept(this);
      currentMethod = n.f2.f0.toString();
	  
      if (!globalFlag) {
    	  if (!enteringExtends && !onlyForExtends) {
    		  Method newMethod = new Method();
		      symbolTable.get(currentClass).methods.put(currentMethod, newMethod);
    	  } else if (enteringExtends && onlyForExtends) {
    		  if (symbolTable.get(currentClass).methods.get(currentMethod) != null) {
    			  symbolTable.get(currentClass).methods.get(currentMethod).overridden = true;
    		  } else {
    			  Method newMethod = new Method();
    			  symbolTable.get(currentClass).methods.put(currentMethod, newMethod);
    		  }
    	  }
    	  if (returnType != null) {
    		  returnTypeMap.put(currentClass + " " + currentMethod, returnType);
    	  }
      }
      
	  n.f3.accept(this);
	  
	  setParamIt();
	  
	  n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      
      //setVarIt(0);
      
      n.f7.accept(this);
      
      if (globalFlag) {
    	  String procedure = new String();
    	  procedure = "\n" + currentClass + "_" + currentMethod + "["
    			 + (symbolTable.get(currentClass).methods.get(currentMethod).args.size() + 1)
    			 + "]\n" + "BEGIN\n";
    	  System.out.println(procedure);
      }
      
      String stmtStar = new String();
      stmtStar = (String)n.f8.accept(this);
	  //System.out.println("pro "+stmtStar);
      
      n.f9.accept(this);
      
      String exp1 = (String)n.f10.accept(this);
      
      n.f11.accept(this);
      n.f12.accept(this);
      if (globalFlag) {
    	  String procedure = new String();
    	  procedure = "RETURN " + exp1 + "\nEND";
    	  //System.err.println("pro "+ stmtStar);
    	  System.out.println(procedure);
      }
      
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n) {
      R _ret=null;
      String type = (String)n.f0.accept(this);
      n.f1.accept(this);
      // Check this flags waala chakkar
      if (!globalFlag) {
    	  if (!onlyForExtends && !enteringExtends) {
    		  String param = new String(); 
	    	  param = n.f1.f0.toString();
	    	  symbolTable.get(currentClass).methods.get(currentMethod)
	    	  	.args.put(param, getParamIt());
			  if (type != null) {
				  methodCall.put(currentClass + " " + currentMethod + " " + param, type);
			  }
    	  } else if (onlyForExtends && enteringExtends) {
    		  if (symbolTable.get(extendClass.get(currentClass)).methods.get(currentMethod)
    				== null) {
        		  String param = new String(); 
    	    	  param = n.f1.f0.toString();
    	    	  symbolTable.get(currentClass).methods.get(currentMethod)
    	    	  	.args.put(param, getParamIt());
    			  if (type != null) {
    				  methodCall.put(currentClass + " " + currentMethod + " " + param, type);
    			  }
    		  }
    	  }
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n) {
      return n.f0.accept(this);
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n) {
      R _ret=null;
      String stmt = (String)n.f0.accept(this);
      
      if (globalFlag) {
    	  //System.err.println("& " + stmt + "%&");
    	  //System.out.println(stmt);
    	  return (R)stmt;
      }
      
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n) {
      R _ret=null;
      n.f0.accept(this);
      
      String stmtStar = (String)n.f1.accept(this);
	  //System.err.println("in block");
      n.f2.accept(this);
     
      if (globalFlag) {
    	  //System.err.println("# " + stmtStar + "%#");
    	  return (R)stmtStar;
      }
      
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n) {
      R _ret=null;
      n.f0.accept(this);
      
      String arg1 = n.f0.f0.toString();
      
      n.f1.accept(this);
      String exp1 = (String)n.f2.accept(this);
      n.f3.accept(this);
           
      if (globalFlag) {
    	  Info classInfo = symbolTable.get(currentClass);
    	  Method methodInfo = classInfo.methods.get(currentMethod);
    	  String aStmt = new String();
    	  
    	  if (methodInfo != null) {
    		  if (methodInfo.args.get(arg1) != null) {    		  
    			  aStmt = "MOVE TEMP " + (methodInfo.args.get(arg1) + 1)
    					  + " " + exp1 + "\n";
    		  } else if (methodInfo.vars.get(arg1) != null) {
    			  aStmt = "MOVE TEMP " + methodInfo.vars.get(arg1) + " " + exp1 + "\n";
    		  } else if (classInfo.variables.get(arg1) != null) {
    			  aStmt = "HSTORE TEMP 0 " + (4 * classInfo.variables.get(arg1) + 4) + " "
    					  + exp1 + "\n";
    		  }
    	  }
    	  System.out.println(aStmt);  
    	  return (R)aStmt;
      }
      
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n) {
      R _ret=null;
      String arg1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String exp1 = (String)n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      String exp2 = (String)n.f5.accept(this);
      n.f6.accept(this);
 
      if (globalFlag) {
    	  Info classInfo = symbolTable.get(currentClass);
    	  Method methodInfo = classInfo.methods.get(currentMethod);
    	  String aStmt = new String();
    	  String pos = getTemp();
    	  String iter = getTemp();
    	  String preVal = getTemp();
    	  
    	  aStmt = "HSTORE PLUS " + arg1 + "\n";
    	  aStmt += "PLUS\n" + "BEGIN\n" + "MOVE " + iter + " TIMES 4 " + exp1 + "\n";
    	  aStmt += "RETURN " + iter + "\nEND\n" + "4 0 " + exp2 + "\n";
    
    	  System.out.println(aStmt);
    	  return (R)aStmt;
      }
	  
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      String exp1 = (String)n.f2.accept(this);
      n.f3.accept(this);
      String ifLabel = "";
	  String elseLabel = "";
	  String endLabel = "";
	  String ifStmt = new String();
	  
	  if (globalFlag) {
    	  ifLabel = getLabel();
    	  elseLabel = getLabel();
    	  endLabel = getLabel();
    	  
    	  ifStmt = "CJUMP " + exp1 + " " + ifLabel + "\n"
    			    + elseLabel + " NOOP";
    	  
    	  System.out.println(ifStmt);
    	  //System.err.println("if& " + ifStmt + "if%&");
    	  //return (R)ifStmt;
      }
	  String stmt1 = (String)n.f4.accept(this);

	  if (globalFlag) {
    	  System.out.println("JUMP " + endLabel + "\n" + ifLabel + " NOOP");
    	  //System.err.println("if& " + ifStmt + "if%&");
    	  //return (R)ifStmt;
      }
	  
	  n.f5.accept(this);
	  String stmt2 = (String)n.f6.accept(this);
	  
      
	  if (globalFlag) {  
    	  System.out.println(endLabel + " NOOP\n");
		  //System.err.println("if& " + ifStmt + "if%&");
    	  //return (R)ifStmt;
      }
	  //TODO initializaions  in var declarations int i;
	 /*
      if (globalFlag) {
    	  ifLabel = getLabel();
    	  elseLabel = getLabel();
    	  endLabel = getLabel();
    	  
    	  ifStmt = "CJUMP " + exp1 + " " + ifLabel + "\n"
    			    + elseLabel + "\n" + stmt2 + "JUMP " + endLabel
    			   	+ "\n" + ifLabel + "\n" + stmt1 + "\n" + endLabel + "\n";
    	  
    	  System.out.println(ifStmt);
    	  System.err.println("if& " + ifStmt + "if%&");
    	  return (R)ifStmt;
      }
     */ 
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n) {
      R _ret=null;
      String endLabel = "";
	  String startLabel = "";
      n.f0.accept(this);
      n.f1.accept(this);

      if (globalFlag) {
    	  endLabel = getLabel();
    	  startLabel = getLabel();
    	  System.out.println("JUMP " + endLabel + "\n" + startLabel + " NOOP");
      }
      
      String exp1 = (String)n.f2.accept(this);
      n.f3.accept(this);
      String stmt1 = (String)n.f4.accept(this);

      if (globalFlag) {
    	  System.out.println(endLabel + " NOOP\n" + "CJUMP " + "MINUS 1 " 
    			  				+ exp1 + " " + startLabel);
      }

      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      String exp1 = (String)n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      
      if (globalFlag) {
    	  String prStmt = new String();
    	  prStmt = "PRINT " + exp1 + "\n";
    	  System.out.println(prStmt);
    	  return (R)prStmt;
      }
      
      return _ret;
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n) {
      R _ret=null;
      
      String exp = (String)n.f0.accept(this);
      
      if (globalFlag) {
    	  //System.err.println("!!" + exp + "!!");
    	  return (R)exp;
      }
      
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&"
    * f2 -> PrimaryExpression()
    */
   // TODO short-circuiting
   public R visit(AndExpression n) {
      R _ret=null;
      String prexp1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String prexp2 = (String)n.f2.accept(this);
	  if (globalFlag) {
		  String aExp = new String();
		  String ans = getTemp();
		  String secLabel = getLabel();
		  String successLabel = getLabel();
		  String failLabel = getLabel();
		  String endLabel = getLabel();
		  //aExp = "TIMES " + prexp1 + " " + prexp2;
		  aExp = "\nBEGIN\n" + "CJUMP " + prexp1 + " " + failLabel + "\n";
		  aExp += "JUMP " + secLabel + "\n";
		  aExp += secLabel + " NOOP\n" + "CJUMP " + prexp2 + " " + failLabel + "\n";
		  aExp +=  "JUMP " + successLabel + "\n";
		  aExp += successLabel + " NOOP\n" + "MOVE " + ans + " 1\n";
		  aExp += "JUMP " + endLabel + "\n";
		  aExp += failLabel + " NOOP\n" + "MOVE " + ans + " 0\n";
		  aExp += "JUMP " + endLabel + "\n";
		  aExp += endLabel + " NOOP\n" + "RETURN " + ans + "\nEND\n";
		  return (R)aExp;
	  }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */

   public R visit(CompareExpression n) {
      R _ret=null;
      String arg1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String arg2 = (String)n.f2.accept(this);
      if (globalFlag) {
	    	String cExp = new String();
	    	String temp = getTemp();
    	  	//cExp = "LT " + arg1 + " " + arg2;
    	  	cExp = "\nBEGIN\n" + "MOVE " + temp + " LT " + arg1 + " " + arg2 + "\n"
    	  			+ "RETURN " + temp + "\nEND\n";
	    	return (R)cExp;
	  }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n) {
      R _ret=null;
      String arg1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String arg2 = (String)n.f2.accept(this);
      if (globalFlag) {
	   	  String aExp = new String();
    	  aExp = "PLUS " + arg1 + " " + arg2;
    	  return (R)aExp;
      }

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n) {
	  R _ret=null;
      String arg1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String arg2 = (String)n.f2.accept(this);
      if (globalFlag) {
    	  String mExp = new String();
    	  //System.err.println("@@@@" + arg1);
	      mExp = "MINUS " + arg1 + " " + arg2;
	      return (R)mExp;
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n) {
      R _ret=null;
      String arg1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String arg2 = (String)n.f2.accept(this);
      if (globalFlag) {
    	  String tExp = new String();
    	  tExp = "TIMES " + arg1 + " " + arg2;
    	  return (R)tExp;
      }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n) {
      R _ret=null;
      String arg1 = (String)n.f0.accept(this);
      n.f1.accept(this);
      String arg2 = (String)n.f2.accept(this);
      n.f3.accept(this);
 
	  if (globalFlag) {
		  String arLookup = new String();
    	  String iter = getTemp();
    	  String ans = getTemp();
    	  
		  arLookup = "\nBEGIN\nHLOAD " + ans + " PLUS " + arg1 + "\n";
    	  arLookup += "PLUS\n" + "BEGIN\n" + "MOVE " + iter + " TIMES 4 " + arg2 + "\n";
    	  arLookup += "RETURN " + iter + "\nEND\n" + "4 0\n RETURN " + ans + "\nEND\n";
		  return (R)arLookup;
	  }
      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   //TODO
   public R visit(ArrayLength n) {
      R _ret=null;
      String exp = (String)n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      if (globalFlag) {
		  String arLength = new String();
    	  String rawAns = getTemp();
    	  String ans = getTemp();
    	  String loopS = getLabel();
    	  String loopE = getLabel();
		  arLength = "\nBEGIN\nHLOAD " + rawAns + " " + exp + " 0\n";
    	  arLength += "MOVE " + ans + " 0\n";
    	  arLength += loopS + " NOOP\nCJUMP LT 0 " + rawAns + "\n" + loopE + " NOOP\n";
    	  arLength += "MOVE " + rawAns + " MINUS " + rawAns + " 4\n";
    	  arLength += "MOVE " + ans + " PLUS " + ans + " 1\n" + "JUMP " + loopS + "\n";
    	  arLength += loopE + " NOOP\n";
    	  arLength += "RETURN " + ans + "\nEND\n";
		  return (R)arLength;
      }
      return _ret;
   }

   /**
    * TODO assuming can be this,identifier,allocation
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n) {
      R _ret=null;
      boolean prevMesFlag = messageFlag;
      messageFlag = true;
      String prexp1 = (String)n.f0.accept(this);
      boolean flag = notThisIdFlag;
	  notThisIdFlag = false;
      messageFlag = false;
      n.f1.accept(this);
      n.f2.accept(this);
      
      String arg1 = new String();
      arg1 = n.f2.f0.toString();
      n.f3.accept(this);
      
      String arguments = new String();
      if (globalFlag) {
    	  argumentStack.push(arguments);
      }
      
      n.f4.accept(this);
      //TODO remove this


      n.f5.accept(this);
      messageFlag = prevMesFlag;
      if (globalFlag) {
    	  String message = new String();
    	  String[] prexp = new String[2];
    	  prexp =  prexp1.split(" ", 2);
    	  String exp1 = argumentStack.pop();
    	  
    	 //if (flag) {
	    	  // allocation expression
	    	  String obj = getTemp();
	    	  String vtable = getTemp();
	    	  String function = getTemp();
	    	  message = "\nCALL\n" + "BEGIN\n" + "MOVE " + obj + "\n" + prexp[1];
	    	  message += "\n" + "HLOAD " + vtable + " " + obj + " 0" + "\n";
	    	  message += "HLOAD " + function + " " + vtable + " "
	    			  		+ (4 * getMethodIndex(prexp[0], arg1)) + "\nRETURN " + function 
	    			  		+ "\n" + "END\n";
	    	  message += "(" + obj + " " + exp1 + ")\n";
	    	  if (returnTypeMap.get(prexp[0] + " " + arg1) != null) {
	    		  returnStack.push(returnTypeMap.get(prexp[0] + " " + arg1));
	    	  } else if (extendClass.get(prexp[0]) != null) {
		    	  String extend = extendClass.get(prexp[0]);
	    		  if (returnTypeMap.get(extend + " " + arg1) != null) {
		    		  returnStack.push(returnTypeMap.get(extend + " " + arg1));
	    		  }
	    	  }
	    	  return (R)message;
    	 /* } else {   		  
    		  message = "\nCALL " + prexp[0] + "_" + arg1 +  " (" 
      			  		+ prexp[1] + " " + exp1 + ")\n";
	    	  if (returnTypeMap.get(prexp[0] + " " + arg1) != null) {
	    		  returnStack.push(returnTypeMap.get(prexp[0] + " " + arg1));
	    	  } else if (extendClass.get(prexp[0]) != null) {
		    	  String extend = extendClass.get(prexp[0]);
	    		  if (returnTypeMap.get(extend + " " + arg1) != null) {
		    		  returnStack.push(returnTypeMap.get(extend + " " + arg1));
	    		  }
	    	  }
    		  return (R)message;
    	  }*/
      }
      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n) {
      R _ret=null;
      String exp = (String)n.f0.accept(this);
      
      if (globalFlag) { 
    	  String arguments = argumentStack.pop();
    	  arguments += exp;
    	  argumentStack.push(arguments);
    	  //System.out.print(exp);
    	  //return (R)expList;
      }
      
      String expRest = (String)n.f1.accept(this);
      
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n) {
      R _ret=null;
      n.f0.accept(this);
      String exp = (String)n.f1.accept(this);
      
      if (globalFlag) {
    	  String arguments = argumentStack.pop();
    	  arguments += " " + exp;
    	  argumentStack.push(arguments);
    	 //String expRest = new String();
    	//expRest = " " + exp;
    	//System.out.print(expRest);
    	//return (R)expRest;
      }
      
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   //TODO flags
   public R visit(PrimaryExpression n) {
      R _ret=null;
      
      if (!globalFlag) {
    	  n.f0.accept(this);
      }
      
      if (globalFlag) {
  		/*  if (messageFlag) {
			  messageFlag = false;
  		  }
  		  */
  		  String prExp = (String)n.f0.accept(this);
  		  return (R)prExp;
      }
      
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      notThisIdFlag = true;
      
      Integer intLit = Integer.parseInt(n.f0.tokenImage);
      return (R)Integer.toString(intLit);
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      notThisIdFlag = true;
      return (R)"1";
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n) {	
      R _ret=null;
      n.f0.accept(this);
      notThisIdFlag = true;
      return (R)"0";
   }

   /**
    * f0 -> <IDENTIFIER>
    */   
   public R visit(Identifier n) {
      R _ret=null;
      n.f0.accept(this);
      if (globalFlag) {
    	  String arg1 = new String();
    	  arg1 = n.f0.toString();
    	  String id = new String();   	  
    	  Info classInfo = symbolTable.get(currentClass);
    	  Method methodInfo = symbolTable.get(currentClass).methods.get(currentMethod);
		  //System.err.println(currentClass);
		  //System.err.println(arg1);
		  //System.err.println(symbolTable.get(currentClass).variables.get(arg1));
		  //System.err.println(classInfo.variables.get(arg1));
		  //System.out.println("message flag " + messageFlag);
    	  if (methodInfo != null) {    		  
    		  if (methodInfo.args.get(arg1) != null) {    		  
    			  id = "TEMP " + (methodInfo.args.get(arg1) + 1);
    			  String var = getTemp();
    			 // id = "\nBEGIN\nHLOAD " + var + " TEMP " + (methodInfo.args.get(arg1) + 1)
    			//		  + " 0\n" + "RETURN " + var + "\nEND\n";
	    	  } else if (methodInfo.vars.get(arg1) != null) {
	    		  id = "TEMP " + methodInfo.vars.get(arg1);
	    	  }
	    	  else if (classInfo.variables.get(arg1) != null) {
	    		  String var = getTemp();
	    		  //System.err.println("AAA");
	    		  id = "\nBEGIN\n";
	    		  id += "HLOAD " + var + " TEMP 0 " + (4*classInfo.variables.get(arg1) + 4);
	    		  id += "\nRETURN " + var + "\nEND\n";
	    	  }
    	  }
    	  
    	  if (messageFlag) {
    		  //System.err.println("in message");
    		  String tempMess = new String();
    		  if (methodCall.get(currentClass + " " + currentMethod + " " + arg1) != null) {
    			  tempMess = methodCall.get(currentClass + " " + currentMethod
    					  		+ " " + arg1);
    		  } else if (methodCall.get(currentClass + " " + " " + arg1) != null){
    			  tempMess = methodCall.get(currentClass + " " + " " + arg1);
    		  } else if (extendClass.get(currentClass) != null) { 
    			  String extend = extendClass.get(currentClass);
    			  if (methodCall.get(extend + " " + currentMethod + " " + arg1) != null) {
    				  tempMess = methodCall.get(extend + " " + currentMethod
					  		+ " " + arg1);
    			  } else if (methodCall.get(extend + " " + " " + arg1) != null){
    				  tempMess = methodCall.get(extend + " " + " " + arg1);
    			  }
    		  }
    		  
    		  tempMess += " " + id;
    		  //System.err.println("out of message");
    		  return (R)tempMess;
    	  } else {
    		  return (R)id;
    	  }
      }
      return (R)n.f0.toString();
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n) {
      R _ret=null;
      n.f0.accept(this);
      
      if (globalFlag) {
    	  String tempMess = new String();
    	  if (messageFlag) {
    		  tempMess = currentClass + " TEMP 0";
    	  } else {
    		  tempMess = "TEMP 0";
    	  }
    	  return (R)tempMess;
      }
      
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      String exp1 = (String)n.f3.accept(this);
      n.f4.accept(this);

      if (globalFlag) {
    	  String newArray = getTemp();
    	  String space = getTemp();
    	  String arExp = new String();
    	  String startLabel = getLabel();
    	  String endLabel = getLabel();
    	  arExp = "\nBEGIN\n";
    	  arExp += "MOVE " + newArray + " HALLOCATE " + "TIMES PLUS " + exp1 + " 1 4\n";
    	  arExp += "MOVE " + space + " 4\n";
    	  arExp += startLabel + " NOOP\n" + "CJUMP LT " + space + " TIMES PLUS " + exp1
    			  	+ " 1 4 " + endLabel + "\n";
    	  arExp += "HSTORE PLUS " + newArray + " " + space + " 0 0\n";
    	  arExp += "MOVE " + space + " PLUS " + space + " 4\n" + "JUMP " + startLabel + "\n";
    	  // storing length
    	  arExp += endLabel + " NOOP\n" + "HSTORE " + newArray + " 0 TIMES " + exp1 + " 4\n";
    	  arExp += "RETURN " + newArray + "\nEND\n";
    	  
    	  notThisIdFlag = true;
    	  return (R)arExp;
      }
      
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      
      if (globalFlag) {
    	  String className = n.f1.f0.toString();
    	  Info toAlloc = symbolTable.get(className);
    	  int numVars = toAlloc.variables.size();
    	  int numMethods = toAlloc.methods.size();
    	  String obj = getTemp();
    	  String vTable = getTemp();
    	  
    	  String allocExp = new String();
    	  if (messageFlag) {
    		  allocExp = className + " ";
    	  } else {
    		  allocExp = "";
    	  }
    	  allocExp += "BEGIN\n";
    	  allocExp += "MOVE " + obj + " HALLOCATE " + ((1 + numVars) * 4) + "\n";
    	  allocExp += "MOVE " + vTable + " HALLOCATE " + (numMethods * 4) + "\n";
    	  int i = 0;
    	 
    	  for (String key : symbolTable.get(className).methods.keySet()) {
    		  if (extendClass.get(className) == null) {
    			  allocExp += "HSTORE " + vTable + " " + (i * 4) + " " + className + "_"
    					  		+ key + "\n";
    		  } else {
    			  String baseClass = extendClass.get(className);
    			  //System.out.println(className + " " + baseClass);
    			  //System.out.println(symbolTable.get("A22").methods.get("go"));
    			  if (symbolTable.get(baseClass).methods.get(key) != null) {
	    			  if (symbolTable.get(className).methods.get(key).overridden) {
	    				  allocExp += "HSTORE " + vTable + " " + (i * 4) + " " 
	    						  		+ className + "_" + key + "\n";
	    			  } else {
	    				  allocExp += "HSTORE " + vTable + " " + (i * 4) + " " 
	    						  		+ baseClass + "_" + key + "\n";
	    			  }
    			  } else {
        			  allocExp += "HSTORE " + vTable + " " + (i * 4) + " " + className + "_"
  					  				+ key + "\n";
    			  }
    		  }
    		  i++;
    	  }
    	
    	  for (i = 1; i <= numVars; ++i) {
    		  allocExp += "HSTORE " + obj + " " + (i * 4) + " 0\n";
    	  }
    	  allocExp += "HSTORE " + obj + " 0 " + vTable + "\n"; 
    	  allocExp += "RETURN " + obj + "\n" + "END\n";
    	  notThisIdFlag = true;
    	  return (R)allocExp;
      }
    	 
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n) {
      R _ret=null;
      n.f0.accept(this);
      String exp1 = (String)n.f1.accept(this);
      if (globalFlag) {
    	  String notExp = new String();
    	  notExp = "MINUS 1 " + exp1;
    	  notThisIdFlag = true;
    	  return (R)notExp;
      }
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n) {
      R _ret=null;
      n.f0.accept(this);
      String exp = (String)n.f1.accept(this);
      n.f2.accept(this); 
      
      if (globalFlag) {
    	  String bExp = new String();
    	  bExp = exp;   	  
    	  notThisIdFlag = true;
    	  if (messageFlag) {
    		  	String returnType = returnStack.pop();
    		  	bExp = returnType + " " + bExp;
    	  }
    	  return (R)bExp;
      }
 
      return _ret;
   }

}
